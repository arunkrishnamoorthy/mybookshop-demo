// Extend, include, localized data and managed compositions

// Is handled together in this file because people want to extend the generated
// definitions in the future.

'use strict';

const { searchName, weakLocation } = require('../base/messages');
const {
  isDeprecatedEnabled,
  forEachGeneric, forEachInOrder, forEachDefinition,
  forEachMember,
  isBetaEnabled,
} = require('../base/model');
const { dictAdd, pushToDict } = require('../base/dictionaries');
const { kindProperties, dictKinds } = require('./base');
const {
  setLink,
  setArtifactLink,
  copyExpr,
  setAnnotation,
  setExpandStatusAnnotate,
  linkToOrigin,
  setMemberParent,
  dependsOnSilent,
  augmentPath,
  pathName,
  splitIntoPath,
  isDirectComposition,
  annotationHasEllipsis,
} = require('./utils');
const layers = require('./moduleLayers');

const $location = Symbol.for('cds.$location');

const genLocation = { file: '' }; // attach stupid location - TODO: remove in v4

function extend( model ) {
  const { options } = model;
  // Get simplified "resolve" functionality and the message function:
  const {
    message, error, warning, info,
  } = model.$messageFunctions;
  const {
    resolvePath,
    resolveUncheckedPath,
    resolveTypeArgumentsUnchecked,
    attachAndEmitValidNames,
    initArtifact,
    initMembers,
  } = model.$functions;

  Object.assign( model.$functions, {
    lateExtensions,
    chooseAnnotationsInArtifact,
    extendArtifactAfter,
  } );

  const extensionsDict = Object.create(null);
  forEachDefinition( model, tagIncludes ); // TODO TMP

  forEachDefinition( model, chooseAnnotationsInArtifact );
  applyExtensions();

  const addTextsLanguageAssoc = checkTextsLanguageAssocOption(model, options);
  const useTextsAspect = checkTextsAspect();

  Object.keys( model.definitions ).forEach( processArtifact );

  compositionChildPersistence();
  return;

  /**
   * Process "composition of" artifacts.
   *
   * @param {string} name
   */
  function processArtifact( name ) {
    const art = model.definitions[name];
    if (!(art.$duplicates)) {
      processAspectComposition( art );
      if (art.kind === 'entity' && !art.query && art.elements)
        // check potential entity parse error
        processLocalizedData( art );
    }
  }

  /**
   * Propagate the given `prop` (e.g. annotation) early, i.e. copy it from all `.includes`
   * if they have the property.
   *
   * @param {XSN.Definition} art
   * @param {string} prop
   */
  function propagateEarly( art, prop ) {
    if (art[prop])
      return;
    for (const ref of art.includes) {
      const aspect = ref._artifact;
      if (aspect) {
        const anno = aspect[prop];
        if (anno && (anno.val !== null || !art[prop]))
          art[prop] = Object.assign( { $inferred: 'include' }, anno );
      }
    }
  }

  /**
   * Copy `@cds.persistence.skip` and `@cds.persistence.skip` from parent to child
   * for managed compositions.  This needs to be done after extensions, i.e. annotations,
   * have been applied or `annotate E.comp` would not have an effect on `E.comp.subComp`.
   */
  function compositionChildPersistence() {
    const processed = new WeakSet();
    forEachDefinition(model, processCompositionPersistence);

    function processCompositionPersistence( def ) {
      if (def.$inferred === 'composition-entity' && !processed.has(def)) {
        if (def._parent)
          processCompositionPersistence(def._parent);
        copyPersistenceAnnotations( def, def._parent );
        processed.add(def);
      }
    }
  }

  // TMP:
  function tagIncludes( art ) {
    if (art.includes)
      extensionsDict[art.name.absolute] = [];
  }

  //-----------------------------------------------------------------------------
  // Extensions: general algorithm
  //-----------------------------------------------------------------------------
  // extendArtifactBefore, extendArtifactAfter, createRemainingAnnotateStatements

  // TODO: assert that we have not yet transformed/used _extensions on sub elements
  // TODO necessary(?): transformArtifactExtensions must ensure that each annotate
  // is in either returns,items,elements,enum
  function extendArtifactAfter( art ) {
    const extensionsMap = art._extensions;
    if (!extensionsMap || art.builtin) // builtin members handled via "super annotate"
      return;
    // type extensions after having “populated” the artifact ($typeArgs -> length,
    // …, TODO: do that there) and setting an _effectiveType:
    if (art.$typeExts) {
      const { type } = art;     // if the type is not inferred, it is the origin...
      if (type?._artifact && !type.$inferred) // ...and thus is resolved
        resolveTypeArgumentsUnchecked( art, type._artifact, art );
      const exts = art.$typeExts;
      applyTypeExtensions( art, exts.length, 'length' );
      const scaleDiff = applyTypeExtensions( art, exts.scale, 'scale' );
      applyTypeExtensions( art, exts.precision, 'precision', scaleDiff );
      applyTypeExtensions( art, exts.srid, 'srid' );
      delete art.$typeExts;
    }
    // TODO tmp: no proper XSN representation yet for annotate … with returns:
    if (art.kind === 'annotate' && !art.returns &&
        (extensionsMap.elements?.some( e => e.$syntax === 'returns' ) ||
         extensionsMap.enum?.some( e => e.$syntax === 'returns' )))
      annotateCreate( art, '', art, 'returns' );

    moveDictExtensions( art, extensionsMap, 'params' );
    // moveReturnsExtensions( art, extensionsMap );
    const sub = art.returns || art.items || art.targetAspect?.elements && art.targetAspect;
    if (sub) {
      if (art.returns) {        // after having applied params!
        extendHandleReturns( extensionsMap.elements, art );
        extendHandleReturns( extensionsMap.enum, art );
      }
      // care about 'ext-unexpected-returns' in a later change if we have XSN returns
      pushToDict( sub, '_extensions', ...extensionsMap.elements || [] );
      pushToDict( sub, '_extensions', ...extensionsMap.enum || [] );
    }
    else {
      moveDictExtensions( art, extensionsMap,
                          (art.enum && art.kind !== 'annotate' ? 'enum' : 'elements'), 'elements' );
      moveDictExtensions( art, extensionsMap, 'enum' );
    }
    moveDictExtensions( art, extensionsMap, 'actions' );
  }

  /**
   * Create super annotate statements for remaining extensions
   */
  function lateExtensions() {   // -> createRemainingAnnotateStatements
    model.extensions = Object.values( model.$lateExtensions );
    // TODO: testMode sort?
    model.extensions.forEach( createSuperAnnotate );
    // set _artifact links for “main extensions” late as it would disturb the
    // still existing old extend mechanism, see chooseAnnotationsInArtifact(),
    // needed for LSP and friends:
    Object.values( model.sources ).forEach( setArtifactLinkForExtensions );
    Object.values( model.definitions ).forEach( setArtifactLinkForExtensions );
  }

  // TODO: delete again
  function setArtifactLinkForExtensions( source ) {
    if (!source.extensions)
      return;
    for (const ext of source.extensions ) {
      const { name } = ext;
      if (name?.absolute && name._artifact === undefined) // no link set yet
        resolvePath( name, ext.kind, ext ); // for LSP
    }
  }

  // For extendArtifactAfter(): -------------------------------------------------

  // Remarks on messages: we allow the type extensions only if the artifact
  // originally had that property → any check of the kind “type prop can only be
  // used with FooBar” is independent from `extend … with type`.  Function
  // checkTypeArguments() in resolve.js reports 'type-unexpected-argument', but
  // that is currently incomplete.
  //
  // We then report (in the future), use the first message of:
  // - the usual messages if a type argument is wrong, independently from `extend`
  // - 'ext-unexpected-type-argument' (TODO) if the artifact does not have the prop
  // - 'ext-invalid-type-argument' if the value is wrong for extend (no overwrite)
  //
  // TODO v4: do not allow `extend … with (precision: …)` alone if original def also has `scale`
  function applyTypeExtensions( art, ext, prop, scaleDiff ) {
    // console.log('ATE:',art?.[prop],ext?.[prop],scaleDiff)
    if (!ext?.[prop])
      return 0;
    if (!art[prop]) {
      const isBuiltin = art._effectiveType?.builtin;
      if (isBuiltin && !allowsTypeArgument( art, prop )) {
        // Let checkTypeArguments() in resolve.js report a message, is incomplete
        // though, i.e. can only safely be used for scalars at the moment.  But we
        // will improve that function and not try to do extra things here.
        art[prop] = ext[prop];  // enable checkTypeArguments() doing its job
        return 0;
      }
      // TODO: think about 'ext-unexpected-type-argument'
      error( 'ext-invalid-type-property', [ ext[prop].location, ext ],
             { '#': (isBuiltin ? 'indirect' : 'new-prop'), prop } );
      return 0;
    }
    const artVal = art[prop].val;
    const extVal = ext[prop].val;
    if (prop === 'srid') {
      error( 'ext-invalid-type-property', [ ext[prop].location, ext ], { '#': 'prop', prop } );
    }
    else if (typeof artVal !== 'number' || typeof extVal !== 'number' ) {
      // Users can't change from/to string value for property,
      // e.g. `variable`/`floating` for Decimal
      // TODO: Shouldn't the text distinguish between orig string and extension string?
      // Not sure whether to talk about strings if we have a keyword in CDL
      error( 'ext-invalid-type-property', [ ext[prop].location, ext ], { '#': 'string', prop } );
    }
    else if (extVal < artVal + (scaleDiff || 0)) {
      const number = artVal + (scaleDiff || 0);
      error( 'ext-invalid-type-property', [ ext[prop].location, ext ],
             // eslint-disable-next-line object-curly-newline
             { '#': (scaleDiff ? 'scale' : 'number'), prop, number, otherprop: 'scale' } );
    }
    else {
      art[prop] = ext[prop];
      return extVal - artVal;
    }
    return 0;
  }

  function allowsTypeArgument( art, prop ) {
    const { parameters } = art._effectiveType;
    if (!parameters)
      return false;
    return parameters.includes( prop ) || parameters[0]?.name === prop;
  }

  function moveDictExtensions( art, extensionsMap, artProp, extProp = artProp ) {
    // TODO: setExpandStatusAnnotate
    const extensions = extensionsMap[extProp];
    if (!extensions)
      return;
    const artDict = art[artProp] || annotateFor( art, extProp ); // no auto-correction in annotate

    for (const ext of extensions) {
      const extDict = ext[extProp];
      for (const name in extDict) {
        let dictCheck = (art.kind !== 'annotate'); // no check in super annotate statement
        const elemExt = extDict[name];
        if (elemExt.kind !== 'annotate' && elemExt.kind !== 'extend') // TODO: specified elems
          continue;             // definitions inside extend, already handled
        dictCheck = dictCheck && checkRemainingMemberExtensions( art, elemExt, artProp, name );
        const elem = artDict[name] || annotateFor( art, extProp, name );
        setLink( elemExt.name, '_artifact', (elem.kind !== 'annotate' ? elem : null) );
        pushToDict( elem, '_extensions', elemExt );
      }
    }
  }

  // function moveReturnsExtensions( art, extensionsMap ) {
  //   const artReturns = art.returns;
  //   const extensions = extensionsMap.returns;
  //   // TODO: artItem is null
  //   for (const ext of extensions)
  //     pushToDict( artReturns, '_extensions', ext.returns );
  // }

  function annotateFor( art, prop, name ) {
    const base = annotateBase( art );
    if (name === '' && prop === 'params')
      return base.returns || annotateCreate( base, name, base, 'returns' );
    const dict = base[prop] || (base[prop] = Object.create( null ));
    if (name == null)
      return dict;
    return dict[name] || annotateCreate( dict, name, base );
  }

  function annotateBase( art ) {
    while (art._outer)          // TOOD: think about anonymous target aspect
      art = art._outer;
    // if (art._annotateS)
    //   return art._annotateS;
    if (art.kind === 'annotate')
      return art;

    // TODO: more to do if annotate can have `returns` property
    if (art.kind === 'select')
      art = art._parent;
    if (art._main)
      return annotateFor( art._parent, kindProperties[art.kind].dict, art.name.id );

    const { absolute } = art.name;
    return model.$lateExtensions[absolute] || annotateCreate( model.$lateExtensions, absolute );
  }

  function annotateCreate( dict, id, parent, prop ) {
    const annotate = {
      kind: 'annotate',
      name: { id, location: genLocation },
      $inferred: '',
      location: genLocation,
    };
    if (parent) {
      setLink( annotate, '_parent', parent );
      setLink( annotate, '_main', parent._main || parent );
    }
    else {
      annotate.name.absolute = id; // TODO later (if all names are sparse): delete absolute
    }
    dict[prop || id] = annotate;
    return annotate;
  }

  function extendHandleReturns( extensions, art ) {
    for (const ext of extensions || []) {
      if (ext.$syntax === 'returns') { // TODO tmp: no proper XSN representation
        ext.$syntax = '$inside-returns';
        delete ext.params;
      }
      else {
        warning( 'ext-expected-returns', [ ext.name.location, ext ], {
          '#': art.kind, keyword: 'returns', code: 'annotate ‹name› with returns { … }',
        }, {
          std: 'Expected $(CODE)', // unused variant
          action: 'Expected $(KEYWORD) when annotating action return structure, i.e. $(CODE)',
          function: 'Expected $(KEYWORD) when annotating function return structure, i.e. $(CODE)',
        } );
      }
    }
  }

  // const unexpected_props = {
  //   elements: 'anno-unexpected-elements',
  //   enum: 'anno-unexpected-elements', // TODO
  //   params: 'anno-unexpected-params',
  //   actions: 'anno-unexpected-actions',
  // };
  // const undefined_props = {
  //   elements: 'anno-undefined-element',
  //   enum: 'anno-undefined-element', // TODO
  //   params: 'anno-undefined-param',
  //   actions: 'anno-undefined-action',
  // };

  function checkRemainingMemberExtensions( parent, ext, prop, name ) {
    // console.log('CRME:',prop,name,parent,ext)
    const dict = parent[prop];
    if (!dict) {
      // TODO: check - for each name? - better locations
      const location = ext._parent[prop][$location] || ext.name.location;
      // Remark: no `elements` dict location with `annotate Main:elem`
      switch (prop) {
        // TODO: change texts, somehow similar to checkDefinitions() ?
        case 'elements':
        case 'enum':            // TODO: extra?
          warning( 'anno-unexpected-elements', [ location, ext._parent ],
                   { '#': (parent._effectiveType?.kind === 'entity') ? 'entity' : 'std' }, {
                     std: 'Elements only exist in entities, types or typed constructs',
                     entity: 'Elements of entity types can\'t be annotated',
                   });
          break;
        case 'params':
          warning( 'anno-unexpected-params', [ location, ext._parent ], {},
                   'Parameters only exist for actions or functions' );
          break;
        case 'actions':
          warning( 'anno-unexpected-actions', [ location, ext._parent ], {},
                   'Actions and functions only exist top-level and for entities' );
          break;
        default:
          // assert
      }
      return false;
    }
    else if (!dict[name]) {
      // TODO: make variant `returns` an auto-variant for ($ART) ?
      const inReturns = parent._parent?.returns && parent._parent;
      const art = inReturns || parent;
      switch (prop) {
        case 'elements':
          notFound( 'anno-undefined-element', ext.name.location, ext,
                    { '#': (inReturns ? 'returns' : 'element'), art, name },
                    parent.elements );
          break;
        case 'enum':            // TODO: extra msg id?
          notFound( 'anno-undefined-element', ext.name.location, ext,
                    { '#': (inReturns ? 'enum-returns' : 'enum'), art, name },
                    parent.enum );
          break;
        case 'params':
          notFound( 'anno-undefined-param', ext.name.location, ext,
                    { '#': 'param', art: parent, name },
                    parent.params );
          break;
        case 'actions':
          notFound( 'anno-undefined-action', ext.name.location, ext,
                    { '#': 'action', art: parent, name },
                    parent.actions );
          break;
        default:
          // assert
      }
    }
    return true;
  }

  function notFound( msgId, location, address, args, validDict ) {
    const msg = message( msgId, [ location, address ], args );
    attachAndEmitValidNames( msg, validDict );
  }

  // For createRemainingAnnotateStatements(): -----------------------------------

  function createSuperAnnotate( annotate ) {
    const extensions = annotate._extensions;
    if (extensions && !annotate._main) {
      const { absolute } = annotate.name;
      const isLocalized = absolute.startsWith( 'localized.' ); // TODO: && anno
      const art = model.definitions[absolute];
      for (const ext of extensions)
        checkRemainingMainExtensions( art, ext, isLocalized );
      if (art?.builtin && art.kind !== 'namespace') { // TODO: do not set `builtin` on cds, cds.hana
        setLink( annotate, '_extensions', art._extensions ); // for messages and member extensions
        // direct annotations on builtins or on the builtins for propagation, and
        // also shallow-copied to $collectedExtensions for to-csn
        for (const prop in art) {
          if (prop.charAt(0) === '@' || prop === 'doc')
            annotate[prop] = art[prop];
        }
      }
      if (extensions.length === 1) { // i.e. no proper location if from more than one extensions
        annotate.location = extensions[0].location;
        annotate.name.location = extensions[0].name.location;
      }
    }
    chooseAnnotationsInArtifact( annotate );
    extendArtifactAfter( annotate );
    forEachMember( annotate, createSuperAnnotate );
  }

  function checkRemainingMainExtensions( art, ext, localized ) {
    if (localized)              // TODO v4: ignore only for annotate
      return;
    if (!resolvePath( ext.name, ext.kind, ext )) // error for extend, info for annotate
      return;
    // else if (ext.kind === 'extend') { // TODO v4 - add error
    // }
    if (art?.kind === 'namespace') {
      // TODO: not at all different to having no definition
      info( 'anno-namespace', [ ext.name.location, ext ], {}, // TODO: better location?
            'Namespaces can\'t be annotated' );
    }
    else if (art?.builtin) {
      info( 'anno-builtin', [ ext.name.location, ext ], {}, // TODO: better location?
            'Builtin types should not be annotated. Use custom type instead' );
    }
  }

  // Issue messages for annotations on namespaces and builtins
  // (TODO: really here?, probably split main artifacts vs returns)
  // see also lateExtensions() where similar messages are reported
  function checkAnnotate( construct, art ) {
    // TODO: Handle extend statements properly: Different message for empty extend?

    // --> without art._block, art not found
    if (construct.kind === 'annotate' && art._block?.$frontend === 'cdl') {
      if (construct.$syntax === 'returns' && art.kind !== 'action' && art.kind !== 'function' ) {
        // `annotate ABC with returns {}` is handled just like `elements`. Warn if it is used
        // for non-actions.  We can't only check for !art.returns, because `action A();` is valid.
        // `art._block` ensures that `art` is a defined def.
        return;
        // warning('ext-unexpected-returns', [ construct.name.location, construct ],
        //         { keyword: 'returns', meta: art.kind }, 'Unexpected $(KEYWORD) for $(META)');
      }
      else if (construct.$syntax !== 'returns' &&
          (art.kind === 'action' || art.kind === 'function') && construct.elements) {
        warning('ext-expected-returns', [ construct.name.location, construct ], {
          '#': art.kind, keyword: 'returns', code: 'annotate ‹name› with returns { … }',
        }, {
          std: 'Expected $(CODE)', // unused variant
          action: 'Expected $(KEYWORD) when annotating action return structure, i.e. $(CODE)',
          function: 'Expected $(KEYWORD) when annotating function return structure, i.e. $(CODE)',
        });
      }
    }
  }

  // extend ------------------------------------------------------------------

  /**
   * Apply the extensions inside the extensionsDict on the model.
   *
   * First try normally: extends with structure includes; with remaining cyclic
   * includes, do so without includes.
   */
  function applyExtensions() {
    let noIncludes = false;
    let extNames = Object.keys( extensionsDict ).sort();

    while (extNames.length) {
      const { length } = extNames;
      for (const name of extNames) {
        const art = model.definitions[name];
        if (art && art.kind !== 'namespace' &&
            extendArtifact( extensionsDict[name], art, noIncludes ))
          delete extensionsDict[name];
      }
      extNames = Object.keys( extensionsDict ); // no sort() required anymore
      if (extNames.length >= length)
        noIncludes = Object.keys( extensionsDict ); // = no includes
    }
  }

  function checkExtensionsKind( extensions, art ) {
    for (const ext of extensions) {
      const kind = ext.expectedKind?.val;
      if (kind && kind !== art.kind) {
        const loc = ext.expectedKind.location;
        if (kind === 'context' || kind === 'service') {
          // We have no real artifact during the construction of a super-annotate statement:
          const msgArgs = {
            '#': (art.kind === 'service' || art.kind === 'annotate') ? art.kind : 'std',
            art,
            kind,
            code: 'extend … with definitions',
            keyword: 'extend service',
          };
          warning( 'ext-invalid-kind', [ loc, ext ], msgArgs, {
            std: 'Artifact $(ART) is not of kind $(KIND), use $(CODE) instead',
            annotate: 'There is no artifact $(ART), use $(CODE) instead',
            // do not mention 'extend context', that is not in CAPire
            service: 'Artifact $(ART) is not of kind $(KIND), use $(CODE) or $(KEYWORD) instead',
          });
        }
        // TODO: Use similar checks for EXTEND ENTITY etc - 'ext-ignoring-kind'
      }
    }
  }

  /**
   * Extend artifact `art` by `extensions`.  `noIncludes` can have values:
   * - false: includes are applied, extend and annotate is performed
   * - true:  includes are not applied, extend and annotate is performed
   * - 'gen': no includes and no extensions allowed, annotate is performed
   *
   * @param {XSN.Extension[]} extensions
   * @param {XSN.Definition} art
   * @param {boolean|'gen'} [noIncludes=false]
   */
  function extendArtifact( extensions, art, noIncludes = false ) {
    if (!noIncludes && !(canApplyIncludes( art, art ) &&
        extensions.every( ext => canApplyIncludes(ext, art) )))
      return false;
    if (Array.isArray( noIncludes )) {
      canApplyIncludes( art, art, noIncludes );
      extensions.forEach( ext => canApplyIncludes( ext, art, noIncludes ) );
    }
    else if (!noIncludes &&
             !(canApplyIncludes( art, art ) &&
               extensions.every( ext => canApplyIncludes( ext, art) ))) {
      // console.log( 'FALSE:',art.name, extensions.map( e => e.name ) )
      return false;
    }
    if (!art.query) {
      model._entities.push( art ); // add structure with includes in dep order
      art.$entity = ++model.$entity;
    }
    if (!noIncludes && art.includes)
      applyIncludes( art, art );
    // checkExtensionsKind( extensions, art );
    extendMembers( extensions, art, noIncludes === 'gen' );
    if (!noIncludes && art.includes) {
      // early propagation of specific annotation assignments
      propagateEarly( art, '@cds.autoexpose' );
      propagateEarly( art, '@fiori.draft.enabled' );
    }
    // TODO: complain about element extensions inside projection
    return true;
  }

  function extendMembers( extensions, art, noExtend ) {
    // TODO: do the whole extension stuff lazily if the elements are requested
    const elemExtensions = [];
    if (art._main)              // extensions already sorted for main artifacts
      extensions.sort( layers.compareLayer );
    // TODO: use same sequence as in chooseAssignment() - better: use common code with that fn
    // console.log('EM:',art.name,extensions,art._extensions)
    for (const ext of extensions) { // those in extMap.includes
      // console.log(message( 'id', [ext.location, ext], { art: ext.name._artifact },
      //                      'Info', 'EXT').toString())
      if (ext.name._artifact === undefined) { // not already applied
        setArtifactLink( ext.name, art );
        if (noExtend && ext.kind === 'extend') {
          error( 'extend-for-generated', [ ext.name.location, ext ], { art },
                 'You can\'t use EXTEND on the generated $(ART)' );
          continue;
        }
        if (ext.includes) {
          // TODO: currently, re-compiling from gensrc does not give the exact
          // element sequence - we need something like
          //    includes = ['Base1',3,'Base2']
          // where 3 means adding the next 3 elements before applying include 'Base2'
          if (art.includes)
            art.includes.push(...ext.includes);
          else
            art.includes = [ ...ext.includes ];
          applyIncludes( ext, art );
        }
        // console.log(ext,art)
        checkAnnotate( ext, art );
        // TODO: do we allow to add elements with array of {...}?  If yes, adapt
        initMembers( ext, art, ext._block ); // might set _extend, _annotate
        dependsOnSilent(art, ext); // art depends silently on ext (inverse to normal dep!)
      }
      for (const name in ext.elements) {
        const elem = ext.elements[name];
        if (elem.kind === 'element') { // i.e. not extend or annotate
          elemExtensions.push( elem );
          break;                // more than one elem in same EXTEND is fine
        }
      }
    }
    if (elemExtensions.length > 1)
      reportUnstableExtensions( elemExtensions );

    // This whole function will be removed with a next change - no need to have nice code here:
    const extsTmp = { elements: Object.create(null), actions: Object.create(null) };
    for (const e of extensions) {
      for (const n in e.elements || []) {
        if (e.elements[n].kind === 'extend')
          pushToDict( extsTmp.elements, n, e.elements[n] );
      }
      for (const n in extensions.actions || []) {
        if (e.actions[n].kind === 'extend')
          pushToDict( extsTmp.actions, n, e.actions[n] );
      }
    }
    [ 'elements', 'actions' ].forEach( (prop) => {
      const dict = extsTmp[prop];
      for (const name in dict) {
        let obj = art;
        if (obj.targetAspect)
          obj = obj.targetAspect;
        while (obj.items)
          obj = obj.items;
        const validDict = obj[prop] || prop === 'elements' && obj.enum;
        const member = validDict && validDict[name];
        if (!member)
          extendNothing( dict[name], prop, name, art, validDict );
        else if (!(member.$duplicates))
          extendMembers( dict[name], member );
      }
    });
  }

  /**
   * Check that special `sap.common.*` aspects for `.texts` entities are
   * consistent with compiler expectations.  Emits messages and returns
   * false if the aspects are not valid.
   *
   * @return {boolean}
   */
  function checkTextsAspect() {
    const textsAspect = model.definitions['sap.common.TextsAspect'];
    if (!textsAspect)
      return false;

    const specialElements = { locale: { key: true } };

    if (textsAspect.kind !== 'aspect' || !textsAspect.elements) {
      error('def-invalid-texts-aspect', [ textsAspect.name.location, textsAspect ],
            { '#': 'no-aspect', art: textsAspect });
      return false;
    }

    let hasError = false;
    if (addTextsLanguageAssoc && textsAspect.elements.language) {
      const lang = textsAspect.elements.language;
      error('def-unexpected-element', [ lang.name.location, lang ],
            { option: 'addTextsLanguageAssoc', art: textsAspect, name: 'language' },
            // eslint-disable-next-line max-len
            '$(ART) is not used because option $(OPTION) conflicts with existing element $(NAME); remove either option or element' );
      hasError = true;
    }

    for (const name in specialElements) {
      const expected = specialElements[name];
      const elem = textsAspect.elements[name];
      if (!elem) {
        error('def-invalid-texts-aspect', [ textsAspect.name.location, textsAspect ],
              { '#': 'missing', art: textsAspect, name });
        hasError = true;
      }
      else if (expected.key !== undefined && !!elem.key?.val !== expected.key) {
        const loc = elem.key?.location || elem.name?.location || textsAspect.name.location;
        error('def-invalid-texts-aspect', [ loc, elem ],
              { '#': expected.key ? 'key' : 'no-key', art: elem });
        hasError = true;
      }
    }

    if (hasError) // avoid subsequent errors, if the special elements are already wrong
      return false;

    for (const name in textsAspect.elements) {
      const elem = textsAspect.elements[name];
      const include = elem.$inferred === 'include';
      if (!specialElements[name] && elem.key) {
        const loc = include ? elem.location : elem.key.location;
        error( 'def-unexpected-key', [ loc, elem ],
               { '#': !include ? 'std' : 'include', art: textsAspect } );
        hasError = true;
      }
      else if (hasTruthyProp( elem, 'localized' )) {
        // TODO: T:loc, i.e. "localized" from other type (needs resolver?)
        //       Not supported anyway, but important for recompilation (which fails correctly).
        const loc = elem.localized?.location || elem.location;
        error( 'def-unexpected-localized', [ loc, elem ],
               { '#': !include ? 'std' : 'include', art: textsAspect } );
        hasError = true;
      }
      else if (elem.targetAspect) {
        error( 'def-unexpected-composition', [ elem.targetAspect.location, elem ],
               { art: textsAspect },
               '$(ART) can\'t have composition of aspects' );
        hasError = true;
      }
    }

    return !hasError;
  }

  /**
   * Report 'Warning: Unstable element order due to repeated extensions'
   * except if all extensions are in the same file.
   *
   * @param {XSN.Extension[]} extensions
   */
  function reportUnstableExtensions( extensions ) {
    // No message if all extensions are in the same file:
    const file = layers.realname( extensions[0] );
    if (extensions.every( ( ext, i ) => !i || file === layers.realname( ext ) ))
      return;
    // Similar to chooseAssignment(), TODO there: also extra intralayer message
    // as this is a modeling error
    let lastExt = null;
    let open = [];              // the "highest" layers
    for (const ext of extensions) {
      const extLayer = layers.layer( ext ) || { realname: '', _layerExtends: Object.create(null) };
      if (!open.length) {
        lastExt = ext;
        open = [ extLayer.realname ];
      }
      else if (extLayer.realname === open[open.length - 1]) { // in same layer
        if (lastExt) {
          message( 'extend-repeated-intralayer', [ lastExt.location, lastExt ] );
          lastExt = null;
        }
        message( 'extend-repeated-intralayer', [ ext.location, ext ] );
      }
      else {
        if (lastExt && (open.length > 1 || !extLayer._layerExtends[open[0]])) {
          // report for lastExt if that is unrelated to other open exts or current ext
          message( 'extend-unrelated-layer', [ lastExt.location, lastExt ], {},
                   'Unstable element order due to other extension in unrelated layer' );
        }
        lastExt = ext;
        open = open.filter( name => !extLayer._layerExtends[name] );
        open.push( extLayer.realname );
      }
    }
  }


  /**
   * @param {XSN.Extension[]} extensions
   * @param {string} prop
   * @param {string} name
   * @param {XSN.Artifact} art
   * @param {object} validDict
   */
  function extendNothing( extensions, prop, name, art, validDict ) {
    const artName = searchName( art, name, dictKinds[prop] );
    for (const ext of extensions) {
      // TODO: use shared functionality with notFound in resolver.js
      const { location } = ext.name;
      const extName = { ...artName, kind: ext.kind };
      const msg
        = error( 'extend-undefined', [ location, extName ],
                 { art: artName },
                 {
                   std: 'Unknown $(ART) - nothing to extend',
                   // eslint-disable-next-line max-len
                   element: 'Artifact $(ART) has no element or enum $(MEMBER) - nothing to extend',
                   action: 'Artifact $(ART) has no action $(MEMBER) - nothing to extend',
                 } );
      attachAndEmitValidNames(msg, validDict);
    }
  }

  // includes ----------------------------------------------------------------

  /**
   * Returns true, if `art.includes` can be applied on `target`.
   * They can't be applied if any of the artifacts referenced in
   * `art.includes` are yet to be extended.
   * `art !== target` if `art` is an extension.
   *
   * @param {XSN.Definition} art
   * @param {XSN.Artifact} target
   * @returns {boolean}
   */
  function canApplyIncludes( art, target, justResolveCyclic ) {
    if (!art.includes)
      return true;
    const isView = !!target.query;
    for (const ref of art.includes) {
      const name = resolveUncheckedPath( ref, 'include', art );
      // console.log('CAI:',justResolveCyclic, name, ref.path, Object.keys(extensionsDict))
      if (justResolveCyclic) {
        if (!justResolveCyclic.includes( name ))
          continue;
        delete ref._artifact;
      }
      else if (name && name in extensionsDict) {
        // one of the includes has itself extensions that need to be applied first
        return false;
      }
      else if (ref._artifact) {
        delete ref._artifact;
      }
      resolvePath( ref, isView ? 'viewInclude' : 'include', art );
    }
    return true;
  }

  /**
   * Apply all includes of `ext` on `ext`.  Checks that `art` allows includes.
   * If `ext === art`, then includes of the artifact itself are applied.
   * If `ext !== art`, applies includes on the extensions, not artifact.
   * Sets `_ancestor` links on `art`.
   *
   * Examples:
   *   ext === art:  `entity E : F {}`  => add elements of F to E
   *   ext !== art:  `extend E with F`  => add elements of F to extension on E
   *
   * @param {XSN.Extension} ext
   * @param {XSN.Artifact} art
   */
  function applyIncludes( ext, art ) {
    if (kindProperties[art.kind].include !== true) {
      error('extend-unexpected-include', [ ext.includes[0]?.location, ext ],
            { meta: art.kind });
      return;
    }

    if (!art.query) {
      if (!art._ancestors)
        setLink( art, '_ancestors', [] ); // recursive array of includes
      for (const ref of ext.includes) {
        const template = ref._artifact;
        // !template -> non-includable, e.g. scalar type, or cyclic
        if (template) {
          if (template._ancestors)
            art._ancestors.push( ...template._ancestors );
          art._ancestors.push( template );
        }
      }
    }
    if (!art.query)    // do not set art.elements and art.enums with query entity!
      includeMembers( ext, art, 'elements' );
    includeMembers( ext, art, 'actions' );
  }

  /**
   * Add all members (e.g. elements or actions) of `ext.includes` to `ext[prop]`.
   * If `art` is `ext`, set the parent link accordingly.
   *
   * @param {XSN.Extension} ext
   * @param {XSN.Artifact} art
   * @param {string} prop: 'elements' or 'actions'
   */
  function includeMembers( ext, art, prop ) {
    // TODO two kind of messages:
    // Error 'More than one include defines element "A"' (at include ref)
    // Warning 'Overwrites definition from include "I" (at elem def)
    const parent = ext === art && art;
    const members = ext[prop];
    ext[prop] = Object.create(null); // TODO: do not set actions property if there are none
    for (const ref of ext.includes) {
      const template = ref._artifact; // already resolved
      if (template) {           // be robust
        forEachInOrder( template, prop, ( origin, name ) => {
          if (members && name in members)
            return;               // TODO: warning for overwritten element
          const elem = linkToOrigin( origin, name, parent, prop, weakLocation( ref.location ) );
          if (!parent) // not yet set for EXTEND foo WITH bar => linkToOrigin() did not add it
            dictAdd( ext[prop], name, elem );
          elem.$inferred = 'include';
          if (origin.masked)
            elem.masked = Object.assign( { $inferred: 'include' }, origin.masked );
          if (origin.key)
            elem.key = Object.assign( { $inferred: 'include' }, origin.key );
          if (origin.value && origin.$syntax === 'calc') {
            // TODO: If paths become invalid in the new artifact, should we mark
            //       all usages in the expressions? Possibly just the first one?
            elem.value = Object.assign( { $inferred: 'include' }, copyExpr( origin.value ));
            elem.$syntax = 'calc';
            setLink( elem, '_calcOrigin', origin._calcOrigin || origin );
          }
          // TODO: also complain if elem is just defined in art
        });
      }
    }
    checkRedefinitionThroughIncludes( parent, prop );
    // TODO: expand elements having direct elements (if needed)
    if (members) {
      forEachInOrder( { [prop]: members }, prop, ( elem, name ) => {
        dictAdd( ext[prop], name, elem );
      });
    }
  }

  /**
   * Report duplicates in parent[prop] that happen due to multiple includes having the
   * same member.  Covers `entity G : E, G {};` but not `entity G : E {};  extend G with F;`.
   *
   * TODO(v4): Make this a hard error; see checkRedefinition(); maybe combine both;
   */
  function checkRedefinitionThroughIncludes( parent, prop ) {
    if (!parent[prop])
      return;
    forEachInOrder(parent, prop, ( member, name ) => {
      if (member.$inferred === 'include' && Array.isArray(member.$duplicates)) {
        const includes = [ member, ...member.$duplicates ].map(dup => dup._origin._main);
        if (isBetaEnabled(options, 'v4preview')) {
          error( 'duplicate-definition', [ parent.name.location, member ],
                 { '#': `include-${ prop }`, name, sorted_arts: includes } );
        }
        else {
          // Error accidentally removed in v2/v3, therefore only a warning.
          warning( 'ref-duplicate-include-member', [ parent.name.location, member ],
                   { '#': prop, name, sorted_arts: includes } );
        }
      }
    });
  }

  // localized texts entities

  /**
   * Process localized data for `art`.  This includes creating `.texts` entities
   * and `locale` associations.
   *
   * @param {XSN.Artifact} art
   */
  function processLocalizedData( art ) {
    const fioriAnno = art['@fiori.draft.enabled'];
    const fioriEnabled = fioriAnno && (fioriAnno.val === undefined || fioriAnno.val);

    const textsName = `${ art.name.absolute }.texts`;
    const textsEntity = model.definitions[textsName];
    const localized = localizedData( art, textsEntity, fioriEnabled );
    if (!localized)
      return;
    if (textsEntity)            // expanded localized data in source
      return;                   // -> make it idempotent
    createTextsEntity( art, textsName, localized, fioriEnabled );
    addTextsAssociations( art, textsName, localized );
  }

  /**
   * Returns `false`, if there is no localized data or an array of elements
   * that are required for `.texts` entities such as keys and localized elements.
   *
   * @param {XSN.Artifact} art
   * @param {XSN.Artifact|undefined} textsEntity
   * @param {boolean} fioriEnabled
   * @returns {false|XSN.Element[]}
   */
  function localizedData( art, textsEntity, fioriEnabled ) {
    let keys = 0;
    const textElems = [];
    const conflictingElements = [];
    // These elements are required or the localized-mechanism does not work.
    // Other elements from sap.common.TextsAspect may be "overridden" as per
    // usual include-mechanism.
    const protectedElements = [ 'locale', 'texts', 'localized' ];
    if (fioriEnabled)
      protectedElements.push('ID_texts');
    if (addTextsLanguageAssoc)
      protectedElements.push('language');

    for (const name in art.elements) {
      const elem = art.elements[name];
      if (elem.$duplicates)
        return false;           // no localized-data unfold with redefined elems
      if (protectedElements.includes( name ))
        conflictingElements.push( elem );

      const isKey = elem.key && elem.key.val;
      const isLocalized = hasTruthyProp( elem, 'localized' );

      if (isKey) {
        keys += 1;
        textElems.push( elem );
      }
      else if (isLocalized) {
        textElems.push( elem );
      }

      if (isKey && isLocalized) { // key with localized is wrong - ignore localized
        const errpos = elem.localized || elem.type || elem.name;
        warning( 'def-ignoring-localized-key', [ errpos.location, elem ], { keyword: 'localized' },
                 'Keyword $(KEYWORD) is ignored for primary keys' );
      }
    }
    if (textElems.length <= keys)
      return false;

    if (!keys) {
      warning( 'def-expecting-key', [ art.name.location, art ], {},
               'No texts entity can be created when no key element exists' );
      return false;
    }

    if (textsEntity) {
      if (textsEntity.$duplicates)
        return false;
      if (textsEntity.kind !== 'entity' || textsEntity.query ||
          // already have elements "texts" and "localized" (and optionally ID_texts)
          conflictingElements.length !== 2 || art.elements.locale ||
          (fioriEnabled && art.elements.ID_texts)) {
        // TODO if we have too much time: check all elements of texts entity for safety
        warning( null, [ art.name.location, art ], { art: textsEntity },
                 // eslint-disable-next-line max-len
                 'Texts entity $(ART) can\'t be created as there is another definition with that name' );
        info( null, [ textsEntity.name.location, textsEntity ], { art },
              'Texts entity for $(ART) can\'t be created with this definition' );
      }
      else if (!art._block || art._block.$frontend !== 'json') {
        info( null, [ art.name.location, art ], {},
              'Localized data expansions has already been done' );
        return textElems;       // make double-compilation even with after toHana
      }
      else if (!art._block.$withLocalized && !options.$recompile) {
        art._block.$withLocalized = true;
        info( 'recalculated-text-entities', [ art.name.location, null ], {},
              'Input CSN contains expansions for localized data' );
        return textElems;       // make compilation idempotent
      }
      else {
        return textElems;
      }
    }
    for (const elem of conflictingElements) {
      warning( null, [ elem.name.location, art ], { name: elem.name.id },
               'No texts entity can be created when element $(NAME) exists' );
    }
    return !textsEntity && !conflictingElements.length && textElems;
  }

  /**
   * Create the `.texts` entity for the given base artifact.
   *
   * @param {XSN.Artifact} base
   * @param {string} absolute
   * @param {XSN.Element[]} textElems
   * @param {boolean} fioriEnabled
   */
  function createTextsEntity( base, absolute, textElems, fioriEnabled ) {
    const art = useTextsAspect
      ? createTextsEntityWithInclude( base, absolute, fioriEnabled )
      : createTextsEntityWithDefaultElements( base, absolute, fioriEnabled );
    // both functions are rather similar...

    const { location } = base.name;

    if (addTextsLanguageAssoc) {
      const language = {
        name: { location, id: 'language' },
        kind: 'element',
        location,
        type: augmentPath( location, 'cds.Association' ),
        target: augmentPath( location, 'sap.common.Languages' ),
        on: {
          op: { val: '=', location },
          args: [
            { path: [ { id: 'language', location }, { id: 'code', location } ], location },
            { path: [ { id: 'locale', location } ], location },
          ],
          location,
        },
      };
      setLink( language, '_block', model.$internal );
      dictAdd( art.elements, 'language', language );
    }

    // assertUnique array value, first entry is 'locale'
    const assertUniqueValue = [];

    for (const orig of textElems) {
      const elem = linkToOrigin( orig, orig.name.id, art, 'elements' );
      if (orig.key && orig.key.val) {
        // elem.key = { val: fioriEnabled ? null : true, $inferred: 'localized', location };
        // TODO: the previous would be better, but currently not supported in toCDL
        if (!fioriEnabled) {
          elem.key = { val: true, $inferred: 'localized', location };
          // If the propagated elements remain key (that is not fiori.draft.enabled)
          // they should be omitted from OData containment EDM
          setAnnotation( elem, '@odata.containment.ignore', location );
        }
        else {
          // add the former key paths to the unique constraint
          assertUniqueValue.push({
            path: [ { id: orig.name.id, location: orig.location } ],
            location: orig.location,
          });
        }
      }
      if (hasTruthyProp( orig, 'localized' )) { // use location of LOCALIZED keyword
        const localized = orig.localized || orig.type || orig.name;
        elem.localized = { val: null, $inferred: 'localized', location: localized.location };
      }
    }

    initArtifact( art );
    if (art.includes) {
      // add elements `locale`, etc. which are required below.
      applyIncludes(art, art);
    }

    if (fioriEnabled) {
      // The includes mechanism puts TextsAspect's elements before .texts' elements.
      // Because ID_texts is not copied from TextsAspect, the order is messed
      // up.  Fix it.
      const { elements } = art;
      art.elements = Object.create(null);
      const names = [ 'ID_texts', 'locale', ...Object.keys(elements) ];
      for (const name of names)
        art.elements[name] = elements[name];

      const { locale } = art.elements;
      assertUniqueValue.unshift({
        path: [ { id: locale.name.id, location: locale.location } ],
        location: locale.location,
      });
      setAnnotation( art, '@assert.unique.locale', art.location, assertUniqueValue, 'array' );
    }

    copyPersistenceAnnotations( art, base );
    return art;
  }

  /**
   * Create the `.texts` entity for the given base artifact.
   * In contrast to createTextsEntityWithDefaultElements(), this one creates
   * an include for `sap.common.TextsAspect`.
   *
   * Does NOT apply the include!
   *
   * @param {XSN.Artifact} base
   * @param {string} absolute
   * @param {boolean} fioriEnabled
   */
  function createTextsEntityWithInclude( base, absolute, fioriEnabled ) {
    const textsAspectName = 'sap.common.TextsAspect';
    const textsAspect = model.definitions['sap.common.TextsAspect'];
    const elements = Object.create(null);
    const { location } = base.name;
    const art = {
      kind: 'entity',
      name: { path: splitIntoPath( location, absolute ), absolute, location },
      includes: [ createInclude( textsAspectName, base.location ) ],
      location: base.location,
      elements,
      $inferred: 'localized-entity',
    };

    if (!fioriEnabled) {
      // To be compatible, we switch off draft without @fiori.draft.enabled
      // TODO (next major version): remove?
      setAnnotation( art, '@odata.draft.enabled', art.location, false );
    }
    else {
      // @fiori.draft.enabled artifacts need default elements ID_texts and locale.
      // `locale` is copied from `sap.common.TextsAspect`, but without "key".
      const textId = {
        name: { location, id: 'ID_texts' },
        kind: 'element',
        key: { val: true, location },
        type: augmentPath( location, 'cds.UUID' ),
        location,
      };
      dictAdd( art.elements, 'ID_texts', textId );

      // "Early" include; only for element `locale`, which has its `key` property
      // removed (or rather: it is not copied).
      linkToOrigin( textsAspect.elements.locale, 'locale', art, 'elements', location );
    }

    if (addTextsLanguageAssoc && art.elements.language)
      art.elements.language = undefined; // TODO: Message? Ignore?
    // TODO: what is this necessary?  We do not create a text entity in this case

    setLink( art, '_block', model.$internal );
    model.definitions[absolute] = art;
    chooseAnnotationsInArtifact( art ); // having extensions here would be wrong
    return art;
  }

  /**
   * @param {XSN.Artifact} base
   * @param {string} absolute
   * @param {boolean} fioriEnabled
   */
  function createTextsEntityWithDefaultElements( base, absolute, fioriEnabled ) {
    const elements = Object.create(null);
    const { location } = base.name;
    const art = {
      kind: 'entity',
      name: { path: splitIntoPath( location, absolute ), absolute, location },
      location: base.location,
      elements,
      $inferred: 'localized-entity',
    };
    // If there is a type `sap.common.Locale`, then use it as the type for the element `locale`.
    // If not, use the default `cds.String` with a length of 14.
    const hasLocaleType = model.definitions['sap.common.Locale']?.kind === 'type';
    const locale = {
      name: { location, id: 'locale' },
      kind: 'element',
      type: augmentPath( location, hasLocaleType ? 'sap.common.Locale' : 'cds.String' ),
      location,
    };
    if (!hasLocaleType)
      locale.length = { literal: 'number', val: 14, location };

    if (!fioriEnabled) {
      locale.key = { val: true, location };
      // To be compatible, we switch off draft without @fiori.draft.enabled
      // TODO (next major version): remove?
      setAnnotation( art, '@odata.draft.enabled', art.location, false );
    }
    else {
      const textId = {
        name: { location, id: 'ID_texts' },
        kind: 'element',
        key: { val: true, location },
        type: augmentPath( location, 'cds.UUID' ),
        location,
      };
      dictAdd( art.elements, 'ID_texts', textId );
    }
    dictAdd( art.elements, 'locale', locale );

    setLink( art, '_block', model.$internal );
    model.definitions[absolute] = art;
    chooseAnnotationsInArtifact( art ); // having extensions here would be wrong
    return art;
  }

  /**
   * @param {XSN.Artifact} art
   * @param {string} textsName
   * @param {XSN.Element[]} textElems
   */
  function addTextsAssociations( art, textsName, textElems ) {
    // texts : Composition of many Books.texts on texts.ID=ID;
    /** @type {array} */
    const keys = textElems.filter( e => e.key && e.key.val );
    const { location } = art.name;
    const texts = {
      name: { location, id: 'texts' },
      kind: 'element',
      location,
      $inferred: 'localized',
      type: augmentPath( location, 'cds.Composition' ),
      cardinality: { targetMax: { literal: 'string', val: '*', location }, location },
      target: augmentPath( location, textsName ),
      on: augmentEqual( location, 'texts', keys ),
    };
    setMemberParent( texts, 'texts', art, 'elements' );
    setLink( texts, '_block', model.$internal );
    // localized : Association to Books.texts on
    //             localized.ID=ID and localized.locale = $user.locale;
    keys.push( [ 'localized.locale', '$user.locale' ] );
    const localized = {
      name: { location, id: 'localized' },
      kind: 'element',
      location,
      $inferred: 'localized',
      type: augmentPath( location, 'cds.Association' ),
      target: augmentPath( location, textsName ),
      on: augmentEqual( location, 'localized', keys ),
    };
    setMemberParent( localized, 'localized', art, 'elements' );
    setLink( localized, '_block', model.$internal );
  }

  /**
   * Create a structure that can be used as an item in `includes`.
   *
   * @param {string} name
   * @param {XSN.Location} location
   */
  function createInclude( name, location ) {
    const include = {
      path: [ { id: name, location } ],
      location,
    };
    setArtifactLink( include.path[0], model.definitions[name] );
    setArtifactLink( include, model.definitions[name] );
    return include;
  }

  /**
   * Returns whether `art` directly or indirectly has the property 'prop',
   * following the 'origin' and the 'type' (not involving elements).
   *
   * DON'T USE FOR ANNOTATIONS (see TODO below)
   *
   * TODO: we should issue a warning if we get localized via TYPE OF
   * TODO: XSN: for anno short form, use { val: true, location, <no literal prop> }
   *       ...then this function also works with annotations
   *
   * @param {XSN.Artifact} art
   * @param {string} prop
   * @returns {boolean}
   */
  function hasTruthyProp( art, prop ) {
    const processed = Object.create(null); // avoid infloops with circular refs
    let name = art.name.absolute;        // is ok, since no recursive type possible
    while (art && !processed[name]) {
      if (art[prop])
        return art[prop].val;
      processed[name] = art;
      if (art._origin) {
        art = art._origin;
        if (!art.name)          // anonymous aspect
          return false;
        name = art && art.name.absolute;
      }
      else if (art.type && art._block && art.type.scope !== 'typeOf') {
        // TODO: also do something special for TYPE OF inside `art`s own elements
        name = resolveUncheckedPath( art.type, 'type', art );
        art = name && model.definitions[name];
      }
      else {
        return false;
      }
    }
    return false;
  }

  // managed composition of aspects ------------------------------------------

  function processAspectComposition( base ) {
    // TODO: we need to forbid COMPOSITION of entity w/o keys and ON anyway
    // TODO: consider entity includes
    // TODO: nested containment
    // TODO: better do circular checks in the aspect!
    if (base.kind !== 'entity' || base.query)
      return;
    const keys = baseKeys();
    if (keys)
      forEachGeneric( base, 'elements', expand ); // TODO: recursively here?
    return;

    function baseKeys() {
      const k = Object.create(null);
      for (const name in base.elements) {
        const elem = base.elements[name];
        if (elem.$duplicates)
          return false;           // no composition-of-type unfold with redefined elems
        if (elem.key && elem.key.val)
          k[name] = elem;
      }
      return k;
    }

    function expand( elem ) {
      if (elem.target)
        return;
      let origin = elem;
      // included element do not have target aspect directly
      while (origin && !origin.targetAspect && origin._origin)
        origin = origin._origin;
      let target = origin.targetAspect;
      if (target && target.path)
        target = resolvePath( origin.targetAspect, 'compositionTarget', origin );
      if (!target || !target.elements)
        return;
      const entityName = `${ base.name.absolute }.${ elem.name.id }`;
      const entity = allowAspectComposition( target, elem, keys, entityName ) &&
            createTargetEntity( target, elem, keys, entityName, base );
      elem.target = {
        location: (elem.targetAspect || elem).location,
        $inferred: 'aspect-composition',
      };
      setArtifactLink( elem.target, entity );
      if (entity) {
        // Support using the up_ element in the generated entity to be used
        // inside the anonymous aspect:
        const { up_ } = target.$tableAliases;
        // TODO: invalidate "up_" alias (at least further navigation) if it
        // already has an _origin (when the managed composition is included)
        if (up_)
          setLink( up_, '_origin', entity.elements.up_ );
        model.$compositionTargets[entity.name.absolute] = true;
        processAspectComposition( entity );
        processLocalizedData( entity );
      }
    }
  }

  /**
   * @returns {boolean|0} `true`, if allowed, `false` if forbidden, `0` if circular containment.
   */
  function allowAspectComposition( target, elem, keys, entityName ) {
    if (!target.elements || Object.values( target.elements ).some( e => e.$duplicates ))
      return false;             // no elements or with redefinitions
    const location = elem.target && elem.target.location || elem.location;
    if ((elem._main._upperAspects || []).includes( target ))
      return 0;               // circular containment of the same aspect

    const keyNames = Object.keys( keys );
    if (!keyNames.length) {
      // TODO: for "inner aspect-compositions", signal already in type
      error( null, [ location, elem ], { target },
             'An aspect $(TARGET) can\'t be used as target in an entity without keys' );
      return false;
    }
    // if (keys.up_) {  // only to be tested if we allow to provide a prefix, which could be ''
    //   // Cannot be in an "inner aspect-compositions" as it would already be wrong before
    //   // TODO: if anonymous type, use location of "up_" element
    //   // FUTURE: add sub info with location of "up_" element
    //   message( 'id', [location, elem], { target, name: 'up_' }, 'Error',
    //      'An aspect $(TARGET) can't be used as target in an entity with a key named $(NAME)' );
    //   return false;
    // }
    if (target.elements.up_) {
      // TODO: for "inner aspect-compositions", signal already in type
      // TODO: if anonymous type, use location of "up_" element
      // FUTURE: if named type, add sub info with location of "up_" element
      error( null, [ location, elem ], { target, name: 'up_' },
             'An aspect $(TARGET) with an element named $(NAME) can\'t be used as target' );
      return false;
    }
    if (model.definitions[entityName]) {
      error( null, [ location, elem ], { art: entityName },
             // eslint-disable-next-line max-len
             'Target entity $(ART) can\'t be created as there is another definition with this name' );
      return false;
    }
    const names = Object.keys( target.elements )
      .filter( n => n.startsWith('up__') && keyNames.includes( n.substring(4) ) );
    if (names.length) {
      // FUTURE: if named type, add sub info with location of "up_" element
      error( null, [ location, elem ], { target: entityName, names }, {
        std: 'Key elements $(NAMES) can\'t be added to $(TARGET) as these already exist',
        one: 'Key element $(NAMES) can\'t be added to $(TARGET) as it already exist',
      });
      return false;
    }

    if (elem.type && !isDirectComposition(elem)) {
      // Only issue warning for direct usages, not for projections, includes, etc.
      // TODO: Make it configurable error; v4: error
      warning( 'def-expected-comp-aspect', [ elem.type.location, elem ],
               { prop: 'Composition of', otherprop: 'Association to' },
               'Expected $(PROP), but found $(OTHERPROP) for composition of aspect');
    }

    return true;
  }

  function createTargetEntity( target, elem, keys, entityName, base ) {
    const { location } = elem.targetAspect || elem.target || elem;
    elem.on = {
      location,
      op: { val: '=', location },
      args: [
        augmentPath( location, elem.name.id, 'up_' ),
        augmentPath( location, '$self' ),
      ],
      $inferred: 'aspect-composition',
    };

    const elements = Object.create(null);
    const art = {
      kind: 'entity',
      name: { path: splitIntoPath( location, entityName ), absolute: entityName, location },
      location,
      elements,
      $inferred: 'composition-entity',
    };
    if (target.name) {          // named target aspect
      setLink( art, '_origin', target );
      setLink( art, '_upperAspects', [ target, ...(elem._main._upperAspects || []) ] );
    }
    else {
      setLink( art, '_origin', target );
      // TODO: do we need to give the anonymous target aspect a kind and name?
      setLink( art, '_upperAspects', elem._main._upperAspects || [] );
    }

    const up = { // elements.up_ = ...
      name: { location, id: 'up_' },
      kind: 'element',
      location,
      $inferred: 'aspect-composition',
      type: augmentPath( location, 'cds.Association' ),
      target: augmentPath( location, base.name.absolute ),
      cardinality: {
        targetMin: { val: 1, literal: 'number', location },
        targetMax: { val: 1, literal: 'number', location },
        location,
      },
    };
    // By default, 'up_' is a managed primary key association.
    // If 'up_' shall be rendered unmanaged, infer the parent
    // primary keys and add the ON condition
    if (isDeprecatedEnabled( options, '_unmanagedUpInComponent' )) {
      addProxyElements( art, keys, 'aspect-composition', target.name && location,
                        'up__', '@odata.containment.ignore' );
      up.on = augmentEqual( location, 'up_', Object.values( keys ), 'up__' );
    }
    else {
      up.key = { location, val: true };
      // managed associations must be explicitly set to not null
      // even if target cardinality is 1..1
      up.notNull = { location, val: true };
    }

    dictAdd( art.elements, 'up_', up);
    addProxyElements( art, target.elements, 'aspect-composition', target.name && location );

    setLink( art, '_block', model.$internal );
    model.definitions[entityName] = art;
    initArtifact( art );

    chooseAnnotationsInArtifact( art ); // having extensions here would be wrong
    // Copy persistence annotations from aspect.
    copyPersistenceAnnotations( art, target ); // after chooseAnnotation()
    return art;
  }

  function addProxyElements( proxyDict, elements, inferred, location, prefix = '', anno = '' ) {
    // TODO: also use for includeMembers()?
    for (const name in elements) {
      const pname = `${ prefix }${ name }`;
      const origin = elements[name];
      const proxy = linkToOrigin( origin, pname, null, null, location || origin.location );
      proxy.$inferred = inferred;
      if (origin.masked)
        proxy.masked = Object.assign( { $inferred: 'include' }, origin.masked );
      if (origin.key)
        proxy.key = Object.assign( { $inferred: 'include' }, origin.key );
      if (anno)
        setAnnotation( proxy, anno );
      dictAdd( proxyDict.elements, pname, proxy );
    }
  }


  // Phase 4 - annotations ---------------------------------------------------
  // move to top

  /**
   * Goes through all (applied) annotations in the given artifact and chooses one
   * if multiple exist according to the module layer.
   * TODO: rename to extendArtifactBefore
   *
   * @param {XSN.Artifact} art
   */
  function chooseAnnotationsInArtifact( art ) {
    // for main artifacts, move extensions from `$lateExtensions` model dictionary:
    if (!art._main && !art._outer && art._extensions === undefined &&
        art.kind !== 'namespace') {
      // if (!art.name) console.log(art)
      const { absolute } = art.name;
      setLink( art, '_extensions', model.$lateExtensions[absolute]?._extensions || null );
      if (art._extensions && !art.builtin) { // keep extensions for builtin in $lateExtensions
        delete model.$lateExtensions[absolute];
        // TODO: if the extension mechanism has been completed, we could uncomment:
        // art._extensions.forEach( ext => resolvePath( ext.name, ext.kind, ext )); // for LSP
        // for now, we do that at the end of lateExtensions()
      }
    }
    if (art._extensions) {
      // TODO: the following function can now be simplified
      // if (art.$inferred) console.log('CAI:', art.name, art.$inferred,art._extensions)
      // With extensions, member appears in CSN, affects directly the rendering of
      // elements etc.  TODO: do that more specifically on the dicts (via symbol)
      // Probably better: we could use the _extensions dict prop directly in to-csn
      if (art.$inferred)
        setExpandStatusAnnotate( art, 'annotate' );
      if (Array.isArray( art._extensions )) {
        checkExtensionsKind( art._extensions, art ); // TODO: check with builtins
        transformArtifactExtensions( art );
      }
      applyAllExtensions( art );
    }
  }

  // TODO: if extensions has more than one of returns,items,elements,enum, delete all those props
  function transformArtifactExtensions( art ) {
    const hasOnlySubExtensions = art._outer; // items, anonymous aspects
    const dict = Object.create(null);
    for (const ext of art._extensions) {
      for (const prop in ext) {
        if (ext[prop] === undefined) // deleted propery
          continue;
        // TODO: do this check nicer (after complete move to new extensions mechanism)
        if (prop.charAt(0) === '@' || prop === 'doc' ||
            prop === 'includes' || prop === 'columns' ||
            prop === 'length' || prop === 'scale' || prop === 'precision' || prop === 'srid') {
          if (!hasOnlySubExtensions)
            pushToDict( dict, prop, ext );
        }
        else if (prop === 'elements' || prop === 'enum' || prop === 'actions' ||
                 prop === 'params' || prop === 'returns') {
          if (ext.kind === 'extend')
            pushToDict( dict, 'includes', ext );
          pushToDict( dict, prop, ext );
        }
      }
    }
    art._extensions = dict;
  }

  function applyAllExtensions( art ) {
    const extensions = art._extensions;
    for (const prop in extensions) {
      // TODO: do the following `if` in a nicer way
      if ([ 'elements', 'enum', 'actions', 'params', 'returns' ].includes( prop ))
        continue;               // currently just annotates on sub elements - TODO: error here
      // annotations, `doc`, `includes`, `columns`, `length`, ...
      const scheduled = [];
      // sort extensions according to layer (specified elements are bottom layer):
      const layered = layeredExtensions( extensions[prop] );

      let cont = true;
      while (cont) {
        const { highest, issue } = extensionsOfHighestLayers( layered );
        // console.log( 'CA:', annoName, issue, extensions)
        let index = highest.length;
        cont = !!index;         // safety
        while (--index >= 0) {
          const ext = highest[index];
          scheduled.push( ext );
          if (extensionOverwrites( ext, prop )) {
            cont = false;
            break;
          }
        }
        if (issue || index > 0)
          reportDuplicateExtensions( highest, prop, issue, index, art );
      }
      // Now apply the relevant extensions
      scheduled.reverse();
      for (const ext of scheduled)
        applySingleExtension( art, ext, prop );
      delete extensions[prop];
    }
  }

  function extensionOverwrites( ext, prop ) {
    return (prop.charAt(0) !== '@')
      ? [ 'doc', 'length', 'precision', 'scale', 'srid' ].includes( prop )
      : !annotationHasEllipsis( ext[prop] );
  }

  // TODO: still a bit annotation assignment specific
  function reportDuplicateExtensions( extensions, prop, issue, index, art ) {
    // TODO: think about messages for these
    if (prop === 'elements' || prop === 'enum' || prop === 'actions' || prop === 'columns' ||
        prop === 'params' || prop === 'returns' || prop === 'includes' )
      return;                   // extensions currently handled extra
    if (issue) {
      // eslint-disable-next-line no-nested-ternary
      let msg = (index < 0)
        ? 'anno-unstable-array'
        : (issue === true)
          ? 'anno-duplicate'
          : 'anno-duplicate-unrelated-layer';
      if (prop.charAt(0) !== '@' && prop !== 'doc') {
        msg = (issue === true)
          ? 'ext-duplicate-extend-type'
          : 'ext-duplicate-extend-type-unrelated-layer';
        // not sure whether to repeat the extended artifact in the message (we
        // have the semantic location, after all)
      }
      const variant = prop === 'doc' ? 'doc' : 'std';
      for (const ext of extensions) {
        const anno = ext[prop];
        if (anno && !anno.$errorReported) {
          message( msg, [ anno.name?.location || anno.location, ext ],
                   { '#': variant, anno: prop, type: art } );
        }
      }
    }
    else if (index > 0) {     // more than one set (not just ...)
      const variant = prop === 'doc' ? 'doc' : 'std';
      const msgid = (prop.charAt(0) === '@' || prop === 'doc')
        ? 'anno-duplicate-same-file' // TODO: always ext-duplicate-…
        : 'ext-duplicate-same-file';
      while (index >= 0) {    // do not report for trailing [...]
        const ext = extensions[index--];
        const anno = ext[prop];
        warning( msgid, [ anno.name?.location || anno.location, ext ],
                 { '#': variant, prop, anno: prop } );
      }
    }
  }

  function applySingleExtension( art, ext, prop ) {
    if (prop === 'includes') {
      if (ext.kind === 'extend' && art.$inferred) {
        error( 'extend-for-generated', [ ext.name.location, ext ], { art },
               'You can\'t use EXTEND on the generated $(ART)' );
      }
      else if (art.kind !== 'annotate' && !art._outer) { // not with elem extension in targetAspect
        const { absolute } = art.name;
        const dict = extensionsDict[absolute] || (extensionsDict[absolute] = []);
        dict.push( ext ); // TODO: change
        // console.log( 'ASI:',prop,art.name,ext,extensionsDict[absolute])
      }
      // art[prop] = (art[prop]) ? art[prop].concat( ext[prop] ) : ext[prop];
    }
    else if (prop === 'columns') {
      const { query } = art;
      if (!query?.from?.path)
        error( 'extend-columns', [ ext.columns[$location], ext ], { art } );
      else if (!query.columns)
        query.columns = [ { location: query.from.location, val: '*' }, ...ext.columns ];
      else
        query.columns.push( ...ext.columns );
    }
    else if ([ 'length', 'precision', 'scale', 'srid' ].includes( prop )) {
      const typeExts = art.$typeExts || (art.$typeExts = {});
      typeExts[prop] = ext;
    }
    else {
      const result = applyAssignment( art[prop], ext[prop], ext, prop );
      art[prop] = (result.name) ? result : Object.assign( {}, art[prop], result );
    }
  }

  function applyAssignment( previousAnno, anno, art, annoName ) {
    const firstEllipsis = annotationHasEllipsis( anno );
    if (!firstEllipsis)
      return anno;
    const hasBase = previousAnno?.literal === 'array';
    if (!previousAnno) {
      const loc = firstEllipsis.location || anno.name.location;
      message( 'anno-unexpected-ellipsis', [ loc, art ], { code: '...' } );
      previousAnno = { val: [] };
    }
    else if (previousAnno.literal !== 'array') {
      // TODO: If we introduce sub-messages, point to the non-array base value.
      error( 'anno-mismatched-ellipsis', [ anno.name.location, art ], { code: '...' } );
      previousAnno = { val: [] };
    }
    const previousValue = previousAnno.val;
    let prevPos = 0;
    const result = [];
    for (const item of anno.val) {
      const ell = item && item.literal === 'token' && item.val === '...';
      if (!ell) {
        result.push( item );
      }
      else {
        let upToSpec = item.upTo && checkUpToSpec( item.upTo, art, annoName, true );
        while (prevPos < previousValue.length) {
          const prevItem = previousValue[prevPos++];
          result.push( prevItem );
          if (upToSpec && prevItem && equalUpTo( prevItem, item.upTo)) {
            upToSpec = false;
            break;
          }
        }
        if (upToSpec && hasBase) {
          // non-matched UP TO; if there is no base to apply to, there is already an error.
          warning( null, [ item.upTo.location, art ], { anno: annoName, code: '... up to' },
                   'The $(CODE) value does not match any item in the base annotation $(ANNO)' );
        }
      }
    }
    // console.log('TP:',previousValue.map(se),anno.val.map(se),'->',result.map(se))
    return { val: result, literal: 'array' };
  }
  // function se(a) { return a.upTo ? [a.val,a.upTo.val] : a.val ; }

  function checkUpToSpec( upToSpec, art, annoName, isFullUpTo ) {
    const { literal } = upToSpec;
    if (!isFullUpTo) {          // inside struct of UP TO
      if (literal !== 'struct' && literal !== 'array' )
        return true;
    }
    else if (literal === 'struct') {
      return Object.values( upToSpec.struct ).every( v => checkUpToSpec( v, art, annoName ) );
    }
    else if (literal !== 'array' && literal !== 'boolean' && literal !== 'null') {
      return true;
    }
    error( null, [ upToSpec.location, art ],
           { anno: annoName, code: '... up to', '#': literal },
           {
             std: 'Unexpected $(CODE) value type in the assignment of $(ANNO)',
             array: 'Unexpected array as $(CODE) value in the assignment of $(ANNO)',
             // eslint-disable-next-line max-len
             struct: 'Unexpected structure as $(CODE) structure property value in the assignment of $(ANNO)',
             boolean: 'Unexpected boolean as $(CODE) value in the assignment of $(ANNO)',
             null: 'Unexpected null as $(CODE) value in the assignment of $(ANNO)',
           } );
    return false;
  }

  function equalUpTo( previousItem, upToSpec ) {
    if (!previousItem)
      return false;
    if ('val' in upToSpec) {
      if (previousItem.val === upToSpec.val) // enum, struct and ref have no val
        return true;
      const typeUpTo = typeof upToSpec.val;
      const typePrev = typeof previousItem.val;
      if (typeUpTo === 'number')
        return typePrev === 'string' && previousItem.val === upToSpec.val.toString();
      if (typePrev === 'number')
        return typeUpTo === 'string' && upToSpec.val === previousItem.val.toString();
    }
    else if (upToSpec.path) {
      return previousItem.path && normalizeRef( previousItem ) === normalizeRef( upToSpec );
    }
    else if (upToSpec.sym) {
      return previousItem.sym && previousItem.sym.id === upToSpec.sym.id;
    }
    else if (upToSpec.struct && previousItem.struct) {
      return Object.entries( upToSpec.struct )
        .every( ([ n, v ]) => equalUpTo( previousItem.struct[n], v ) );
    }
    return false;
  }

  function normalizeRef( node ) { // see to-csn.js
    const ref = pathName( node.path );
    return node.variant ? `${ ref }#${ node.variant.id }` : ref;
  }

  /**
   * Copy the annotations `@cds.persistence.skip`/`@cds.persistence.exists` from
   * source to target if present on source but not target.
   *
   * @param {object} target
   * @param {object} source
   */
  function copyPersistenceAnnotations( target, source ) {
    if (!source)
      return;

    const copyExists = !isDeprecatedEnabled( options, 'eagerPersistenceForGeneratedEntities' );
    if (copyExists)
      copy( '@cds.persistence.exists' );
    copy( '@cds.persistence.skip' );

    function copy( anno ) {
      if ( source[anno] && !target[anno] )
        target[anno] = { ...source[anno], $inferred: 'parent-origin' };
    }
  }
}

/**
 * Group extensions by their layers.  A definition (for specified elements)
 * is considered to be provided in a layer named '', the lowest layer.
 *
 * @param {object[]} extensions Array of extensions.
 * @returns {Record<string, object>} key: layer name, value: {name, layer, extensions[]}`
 */
function layeredExtensions( extensions ) {
  const layered = Object.create(null);
  for (const ext of extensions) {
    const layer = (ext.kind === 'annotate' || ext.kind === 'extend') && layers.layer( ext );
    // just consider layer if Extend/Annotate, not Define
    const name = (layer) ? layer.realname : '';
    const done = layered[name];
    if (done)
      done.extensions.push( ext );
    else
      layered[name] = { name, layer, extensions: [ ext ] };
  }
  return layered;
}

/**
 * Return extensions of the highest layers.
 * Also returns whether there could be an issue:
 * - false: there are just extensions in one file,
 * - 'unrelated': there is just one extension per layer
 * - true: there is at least one layer with two or more extensions, and
 *   at least two files are involved
 *
 * @param {Record<string, object>} layered Structure as returned by layeredExtensions()
 * @returns {{assignments, issue: boolean|string}}
 */
function extensionsOfHighestLayers( layered ) {
  const layerNames = Object.keys( layered );
  // console.log('HIB:',layerNames)
  if (layerNames.length <= 1) {
    const name = layerNames[0];
    const highest = layered[name]?.extensions || [];
    delete layered[name];
    return { highest, issue: inMoreThanOneFile( highest ) };
  }

  // collect all layers which are lower than another layer
  const allExtends = Object.create(null);
  allExtends[''] = {};        // the "Define" layer
  for (const name of layerNames) {
    if (name)                 // not the "Define" layer
      Object.assign( allExtends, layered[name].layer._layerExtends );
  }
  // console.log('HIE:',Object.keys(allExtends))
  const highest = [];           // extensions
  const highestLayers = [];
  for (const name of layerNames) {
    if (!(name in allExtends)) {
      const layer = layered[name];
      delete layered[name];
      highestLayers.push( layer );
      highest.push( ...layer.extensions );
    }
  }
  highest.sort( compareExtensions );
  const good = highestLayers.every( layer => !inMoreThanOneFile( layer.extensions ));
  // TODO: use layer.file instead
  const issue = !good || highestLayers.length > 1 && 'unrelated';
  // console.log('HI:',highest.map(l=>l.name),issue,issue&&extensions)
  return { highest, issue };
}

function inMoreThanOneFile( extensions ) {
  if (extensions.length <= 1)
    return false;
  const file = extensions[0].location?.file;
  return !file || extensions.slice(1).some( e => e.location?.file !== file );
}

/**
 * Compare two extensions which are not comparable via layering:
 * - via the fs.realpath of the file (not layer!) of the extensions, then
 * - via the line, then column of the extensions.
 * Returns <0 if `a`<`b`, >1 if `a`>`b`, i.e. can be used for ascending sort.
 */
function compareExtensions( a, b ) {
  const fileA = layers.realname( a._block );
  const fileB = layers.realname( b._block );
  if (fileA !== fileB)
    return (fileA > fileB) ? 1 : -1;
  return (a?.location?.line || 0) - (b?.location?.line || 0) ||
    (a?.location?.col || 0) - (b?.location?.col || 0);
}

function augmentEqual( location, assocname, relations, prefix = '' ) {
  const args = relations.map( eq );
  return (args.length === 1)
    ? args[0]
    : { op: { val: 'and', location }, args, location };

  function eq( refs ) {
    if (Array.isArray(refs))
      return { op: { val: '=', location }, args: refs.map( ref ), location };

    const { id } = refs.name;
    return {
      op: { val: '=', location },
      args: [
        { path: [ { id: assocname, location }, { id, location } ], location },
        { path: [ { id: `${ prefix }${ id }`, location } ], location },
      ],
      location,
    };
  }
  function ref( path ) {
    return { path: path.split('.').map( id => ({ id, location }) ), location };
  }
}

/**
 * If the given extension is a `EXTEND <def> WITH TYPE` extension, store
 * it in the given artifact.  resolve.js will resolve types and call
 * `typeExtensions()` later.
 *
 * @param {XSN.Extension} ext
 * @param {object} art
 */
// function storeTypeExtension( ext, art ) {
//   // If there are no parameters to apply, don't store the extension.
//   if (!typeParameters.list.some( prop => ext[prop] !== undefined ))
//     return;
//   else if (!art._extendType)
//     setLink( art, '_extendType', [] );
//   art._extendType.push( ext );
// }

function checkTextsLanguageAssocOption( model, options ) {
  const languages = model.definitions['sap.common.Languages'];
  const commonLanguagesEntity = options.addTextsLanguageAssoc && languages?.elements?.code;

  if (options.addTextsLanguageAssoc && !commonLanguagesEntity) {
    const variant = !languages ? 'std' : 'code';
    const loc = model.definitions['sap.common.Languages']?.name?.location || null;
    model.$messageFunctions.info('api-ignoring-language-assoc', loc, {
      '#': variant, option: 'addTextsLanguageAssoc', art: 'sap.common.Languages', name: 'code',
    }, {
      std: 'Ignoring option $(OPTION) because entity $(ART) is missing',
      code: 'Ignoring option $(OPTION) because entity $(ART) is missing element $(NAME)',
    });
  }

  return !!commonLanguagesEntity;
}


module.exports = extend;
